<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verify</title>
</head>
<body>
    <style>
        body {
            font-family: system-ui;
        }
        a, a:active, a:visited {
            color: inherit;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        #output {
            word-break: break-all;
        }
        .log { color: black; }
        .warn { color: orange; }
        .alert { color: red; }
        .ok { color: green; }
        
    </style>
    <textarea id="txt-url" placeholder="URL"></textarea><br>
    <textarea id="txt-sig" placeholder="(Optional) Signature"></textarea><br>
    <button id="btn-verify">Verify</button>
    <div id="output"></div>
    
    <script type="module">
        import * as util from './util.mjs';
        
        const txt_url = document.querySelector('#txt-url');
        const txt_sig = document.querySelector('#txt-sig');
        const btn_verify = document.querySelector('#btn-verify');
        const div_output = document.querySelector('#output');
        
        function linkify(str) {
            console.log(typeof str);
            if (typeof str !== 'string' || (!str.startsWith('http://') && !str.startsWith('https://'))) {
                return str;
            }
            try {
                const url = new URL(str);
                return `<a href="${url.href}">${str}</a>`;
            } catch {
                return str;
            }
        }
        
        function append_log(strings, cls = '') {
            if (!Array.isArray(strings)) { strings = [strings]; }
            strings = strings.map(linkify);
            output.innerHTML += `<div class="${cls}">${strings.join(' ')}</div>`;
        }
        
        function log(...msgs) { append_log(msgs, 'log'); }
        function warn(...msgs) { append_log(msgs, 'warn'); }
        function alert(...msgs) { append_log(msgs, 'alert'); }
        function ok(...msgs) { append_log(msgs, 'ok'); }
        
        async function load_siginfo() {
            log('Verifying URL:', txt_url.value);
            const url = new URL('./siginfo.json', txt_url.value).href;
            const siginfo = await util.fetch_json(url);
            log('Siginfo:', url);
            // TODO: no siginfo found
            return siginfo;
        }
        
        function process_sitemap(files) {
            return files.map(f => util.make_url(f, txt_url.value));
        }
        
        async function verify() {
            output.innerHTML = '';
            const siginfo = await load_siginfo();
            console.log(siginfo);
            
            // TODO: check that siginfo is signed
            // TODO: check that timestamp is signed
            // TODO: check that signed files are on the checked domain
            let sig = txt_sig.value;
            if (!sig) {
                sig = await util.fetch_text(util.make_url(siginfo.signature_url , txt_url.value));
            }
            log('Signature:', sig);
            
            const public_key_url = new URL('../crypto/public_key.pem', location.href).href;
            const public_key = await util.load_public_key(public_key_url);
            log('Public key:', public_key_url);
            
            const files = process_sitemap(siginfo.sitemap);
            log('Files to verify:', files.length);
            const data_buffers = await Promise.all(files.map(path => {
                log('Verifying:', path);
                return util.fetch_ab(path);
            }));
            
            const data = util.join_buffers(data_buffers);
            log('Total bytes to verify:', data.byteLength);
            
            const valid = await util.verify(public_key, sig, data);
            if (valid) {
                ok(`VALID\n\n`);
                log(`<img src="${util.make_url(siginfo.metadata.image_url, txt_url.value)}" style="max-width:200px;"/>`)
                log(JSON.stringify(siginfo.metadata));
                const timestamp = await util.fetch_text(util.make_url(siginfo.timestamp_url , txt_url.value));
                log(`Signature Timestamp: ${timestamp}`)
                
            } else {
                alert(`NOT VALID`);
            }
        }
        
        btn_verify.onclick = verify;
        
        /* 
            VALID means:
            * The data is complete and unchanged from it's original state (Integrity)
            * The data is verified to be from Process Studio (Authenticity)
         
            INVALID means:
            * The data was changed or tammpered with
            * The signature was changed or tampered with
        */
        
        const query = new URLSearchParams(window.location.search);
        const url = query.get('url');
        if (url) { txt_url.value = url; }
        if (txt_url.value === '') { txt_url.value = location.origin; }
        const sig = query.get('sig');
        if (sig) { txt_sig.value = sig; }
        
        verify();
        
    </script>
    
</body>
</html>
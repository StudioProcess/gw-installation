<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verify</title>
    <script src="https://unpkg.com/qrcode@1.5.1/build/qrcode.js"></script>
</head>
<body>
    <style>
        body {
            font-family: system-ui;
        }
        a, a:active, a:visited {
            color: inherit;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        textarea { width: 99%; }
        #output {
            max-height: 100px;
            overflow-y: scroll;
        }
        .log { color: black; }
        .warn { color: darkorange; }
        .alert { color: red; }
        .ok { color: green; }
        .qrcode { max-width: 150px; }
    </style>
    <textarea id="txt-url" rows="1" placeholder="URL"></textarea><br>
    <textarea id="txt-sig" placeholder="(Optional) Signature"></textarea><br>
    <button id="btn-verify">Verify</button>
    <div id="output"></div>
    <div id="result"></div>
    
    <script type="module">
        import * as util from './util.mjs';
        
        const SIGINFO_URL = './siginfo.json'; // Relative to the checked site
        const PUBLIC_KEY_URL = './public_key.pem'; // Relative to this file
        
        const txt_url = document.querySelector('#txt-url');
        const txt_sig = document.querySelector('#txt-sig');
        const btn_verify = document.querySelector('#btn-verify');
        const div_output = document.querySelector('#output');
        const div_result = document.querySelector('#result');
        let origin = '';
        
        function linkify(str) {
            if (typeof str !== 'string' || (!str.startsWith('http://') && !str.startsWith('https://'))) {
                return str;
            }
            try {
                const url = new URL(str);
                return `<a href="${url.href}" target="_blank">${str}</a>`;
            } catch {
                return str;
            }
        }
        
        let log_output = div_output;
        function set_log_output(el) { log_output = el; }
        function append_log(strings, cls = '') {
            if (!Array.isArray(strings)) { strings = [strings]; }
            strings = strings.map(linkify);
            log_output.innerHTML += `<div class="${cls}">${strings.join(' ')}</div>`;
            log_output.scrollTop = log_output.scrollHeight; // scroll to bottom (in case this is scrollable)
        }
        
        function log(...msgs) { append_log(msgs, 'log'); }
        function warn(...msgs) { append_log(msgs, 'warn'); }
        function alert(...msgs) { append_log(msgs, 'alert'); }
        function ok(...msgs) { append_log(msgs, 'ok'); }
        
        function check_origin(url) {
            return url.toLowerCase().startsWith(origin.toLowerCase());
        }
        
        async function load_siginfo(url) {
            const siginfo_url = util.make_url(url, origin);
            let siginfo;
            try {
                siginfo = await util.fetch_json(siginfo_url);
                log('Signature info:', siginfo_url);
            } catch {
                warn('Signature info not found');
                return false;
            }
            
            if (!siginfo.version) {
                warn('Siginfo: version missing');
                return false;
            }
            
            if (!Array.isArray(siginfo?.sitemap)) {
                warn('Siginfo: sitemap missing');
                return false;
            }
            siginfo.sitemap = siginfo.sitemap.map(f => util.make_url(f, origin));
            
            // Check that signed files are within the checked domain
            for (let file of siginfo.sitemap) {
                if (!check_origin(file)) {
                    warn('Siginfo: File outside of checked domain:', file);
                    return false;
                }
            }
            // log('Siginfo: All files within checked domain');
            
            // Check that siginfo is signed
            if (!siginfo.sitemap.includes(siginfo_url)) {
                warn(`Siginfo: ${url} not included in signature`);
                return false;
            }
            // log(`Siginfo: ${url} included in signature`);
            
            // Check that timestamp is signed (if present)
            if (siginfo.timestamp_url) {
                siginfo.timestamp_url = util.make_url(siginfo.timestamp_url, origin);
                if (!check_origin(siginfo.timestamp_url)) {
                    warn(`Siginfo: Timestamp outside of checked domain: ${siginfo.timestamp_url}`);
                    return false;
                }
                if (!siginfo.sitemap.includes(siginfo.timestamp_url)) {
                    warn(`Siginfo: Timestamp not included in signature: ${siginfo.timestamp_url}`);
                    return false;
                }
            }
            // log(`Siginfo: Timestamp included in signature`);
            
            // Check that image_url is signed (if present)
            if (siginfo?.metadata.image_url) {
                siginfo.metadata.image_url = util.make_url(siginfo.metadata.image_url, origin);
                if (!check_origin(siginfo.metadata.image_url)) {
                    warn(`Siginfo: Image outside of checked domain: ${siginfo.metadata.image_url}`);
                    return false;
                }
                if (!siginfo.sitemap.includes(siginfo.metadata.image_url)) {
                    warn(`Siginfo: Image not included in signature: ${siginfo.metadata.image_url}`);
                    return false;
                }
            }
            // log(`Siginfo: Image included in signature`);
            
            // Process signature URL (if present)
            if (siginfo.signature_url) {
                siginfo.signature_url = util.make_url(siginfo.signature_url, origin);
            }
            
            return siginfo;
        }
        
        async function verify() {
            output.innerHTML = '';
            result.innerHTML = '';
            set_log_output(div_output);
            
            let start_ts = new Date();
            log('Verification started:', util.ts_local(start_ts));
            
            origin = txt_url.value.trim();
            if (!origin.endsWith('/')) { origin += '/'; } // make sure the URL ends with a slash, so make_url doesn't remove the last path part
            log('Verifying site:', origin);
            
            // Check crypto.subtle
            if (!util.check_crypto()) {
                warn("This browser does not support the crypto module");
                return;
            }
            
            // Check HTTPS
            if (!origin.toLowerCase().startsWith('https://') 
                && !origin.toLowerCase().startsWith('http://localhost:')) {
                warn('Cannot verify. HTTPS is required');
                return;
            }
            
            // Load siginfo
            const siginfo = await load_siginfo(SIGINFO_URL);
            if (!siginfo) {
                return;
            }
            
            // Get signature (from input/querystring or siginfo)
            let sig = txt_sig.value;
            if (!sig) {
                if (!siginfo.signature_url) {
                    warn('No signature provided');
                    return;
                }
                try {
                    sig = await util.fetch_text(siginfo.signature_url);
                    log('Signature:', siginfo.signature_url);
                } catch {
                    warn('Cannot load signature:', siginfo.signature_url);
                    return;
                }
            } else {
                log('Signature:', `<span style="word-break: break-all;">${sig}</span>`);
            }
            
            log('Files to verify:', siginfo.sitemap.length);
            const data_buffers = [];
            try {
                for (let [idx, file] of siginfo.sitemap.entries()) {
                    let buf = await util.fetch_ab(file);
                    log(`(${idx+1})`, file);
                    data_buffers.push(buf);
                }
            } catch (e) {
                warn('Cannot load file:', e.url);
                return;
            }
            
            const data = util.join_buffers(data_buffers);
            log('Total bytes to verify:', new Intl.NumberFormat('en').format(data.byteLength));
            
            
            const public_key_url = util.make_url(PUBLIC_KEY_URL, location.origin + location.pathname);
            let public_key;
            try {
                public_key = await util.load_public_key(public_key_url);
            } catch {
                warn('Cannot load public key:', public_key_url);
                return;
            }
            log('Public key:', public_key_url);
            
            let valid;
            try {
                valid = await util.verify(public_key, sig, data);
            } catch (e) {
                console.warn(e);
            }
            const end_ts = new Date();
            log('Verification finished:', util.ts_local(end_ts));
            log('Verification took:', util.format_duration(end_ts-start_ts));
            log('Result (Signature valid?):', valid);
            
            set_log_output(div_result);
            if (valid) {
                ok(`✅ SIGNATURE VALID`);
                append_log([
                    '<ul>',
                    '<li>The data is complete and unchanged from its original state (Integrity), and</li>',
                    '<li>The data originates from <a href="https://process.studio">Process Studio</a> (Authenticity)</li>',
                    '</ul>'
                ]);
                
                if (siginfo?.metadata.image_url) {
                    append_log(`<a href="${origin}"><img src="${siginfo.metadata.image_url}" style="max-width:200px;"/></a>`, 'image');
                }
                append_log(`<a href="${origin}">${origin}</a>`, 'link');
                if (siginfo?.metadata.title) {
                    append_log(siginfo.metadata.title, 'title');
                }
                if (siginfo?.metadata.author) {
                    append_log(siginfo.metadata.author, 'author');
                }
                
                if (siginfo.timestamp_url) {
                    try {
                        let timestamp = await util.fetch_text(siginfo.timestamp_url);
                        timestamp = new Date(timestamp);
                        append_log(['Signed:', util.ts_local(timestamp)], 'timestamp');
                    } catch { /* nop */ }
                }
                append_log(['Verified:', util.ts_local(end_ts)], 'timestamp');
                
                if (window.QRCode) {
                    const url = `${location.origin}${location.pathname}?url=${encodeURIComponent(origin)}&sig=${encodeURIComponent(sig)}`;
                    const svg = await window.QRCode.toString(url, {type: 'svg'});
                    const svg_uri = `data:image/svg+xml;base64,${btoa(svg)}`;
                    append_log(`<a href="${url}"><img src="${svg_uri}"></a>`, 'qrcode');
                }
                
            } else {
                alert(`❌ SIGNATURE NOT VALID`);
                append_log([
                    '<ul>',
                    '<li>The data is incomplete, was changed or tampered with, and/or</li>',
                    '<li>The signature was changed or tampered with</li>',
                    '</ul>'
                ]);
            }
        }
        
        btn_verify.onclick = verify;
        
        const verify_on_enter = e => {
            if (e.key === 'Enter') {
                e.preventDefault();
                e.target.blur();
                verify();
            }
        };
        txt_url.onkeydown = verify_on_enter;
        txt_sig.onkeydown = verify_on_enter;
        
        const query = new URLSearchParams(window.location.search);
        const url = query.get('url');
        if (url) { txt_url.value = url; }
        if (txt_url.value === '') { txt_url.value = location.origin + location.pathname; }
        const sig = query.get('sig');
        if (sig) { txt_sig.value = sig; }
        
        verify();
        
    </script>
    
</body>
</html>